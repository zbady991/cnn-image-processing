# -*- coding: utf-8 -*-
"""CNN Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FKsogGn6YtI670k-7MC-fQNeJ-sugPLg
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

# It's assumed that a file named 'image.jpg' exists in the same directory.
# Replace 'image.jpg' with your image file name.
try:
    img = cv2.imread('/content/ele.png')
    if img is None:
        raise FileNotFoundError("Image file not found.")
except FileNotFoundError as e:
    print(e)
    exit()

# --- Task 1: Image Rotation ---
# Rotate the image 30 degrees clockwise around its center[cite: 3].
# Keep the same dimensions as the original[cite: 4].
(h, w) = img.shape[:2]
center = (w // 2, h // 2)
M_rot = cv2.getRotationMatrix2D(center, -30, 1.0)
rotated_img = cv2.warpAffine(img, M_rot, (w, h))

# --- Task 2: Image Translation (Shifting) ---
# Shift the image 100 pixels to the right and 70 pixels down[cite: 8].
# Use a translation matrix with cv2.warpAffine[cite: 9].
M_trans = np.float32([[1, 0, 100], [0, 1, 70]])
translated_img = cv2.warpAffine(img, M_trans, (w, h))

# --- Task 3: Image Shearing ---
# Apply a horizontal shear with a factor of -0.15[cite: 13].
M_shear = np.float32([[1, -0.15, 0], [0, 1, 0]])
sheared_img = cv2.warpAffine(img, M_shear, (w, h))

# --- Task 4: Image Normalization ---
# Split the image into R, G, B channels[cite: 16].
b, g, r = cv2.split(img)
# Normalize each channel's values to the range [0, 1][cite: 17].
b_norm = b.astype(np.float32) / 255.0
g_norm = g.astype(np.float32) / 255.0
r_norm = r.astype(np.float32) / 255.0
# Merge the normalized channels back into one image[cite: 18].
normalized_img = cv2.merge([b_norm, g_norm, r_norm])

# --- Task 5: Image Blurring ---
# Apply Gaussian Blur with a kernel (3,3)[cite: 21].
blurred_img = cv2.GaussianBlur(img, (3, 3), 0)

# --- Displaying Images using Matplotlib ---
fig, axes = plt.subplots(5, 2, figsize=(10, 25))


# Task 2: Translation
axes[1, 0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
axes[1, 0].set_title('Original Image')
axes[1, 1].imshow(cv2.cvtColor(translated_img, cv2.COLOR_BGR2RGB))
axes[1, 1].set_title('Translated Image')

# Task 3: Shearing
axes[2, 0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
axes[2, 0].set_title('Original Image')
axes[2, 1].imshow(cv2.cvtColor(sheared_img, cv2.COLOR_BGR2RGB))
axes[2, 1].set_title('Sheared Image')

# Task 4: Normalization
axes[3, 0].axis('off') # Hide this subplot as we only show one image
axes[3, 1].imshow(cv2.cvtColor(np.uint8(normalized_img * 255), cv2.COLOR_BGR2RGB))
axes[3, 1].set_title('Normalized Image')

# Task 5: Blurring
axes[4, 0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
axes[4, 0].set_title('Original Image')
axes[4, 1].imshow(cv2.cvtColor(blurred_img, cv2.COLOR_BGR2RGB))
axes[4, 1].set_title('Blurred Image')

plt.tight_layout()
plt.show()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Read the image
img = cv2.imread('/content/ele.png')

# Get image dimensions
(h, w) = img.shape[:2]

# Calculate the center of the image
center = (w // 2, h // 2)

# Get the rotation matrix
M_rot = cv2.getRotationMatrix2D(center, -30, 1.0)

# Apply the rotation to the image
rotated_img = cv2.warpAffine(img, M_rot, (w, h))

# Display original vs rotated images
cv2_imshow(img)
cv2_imshow(rotated_img)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Read the image
img = cv2.imread('/content/ele.png')

# Get image dimensions
(h, w) = img.shape[:2]

# Create the translation matrix
M_trans = np.float32([[1, 0, 100], [0, 1, 70]])

# Apply the translation to the image
translated_img = cv2.warpAffine(img, M_trans, (w, h))

# Display original vs translated images
cv2_imshow(img)
cv2_imshow(translated_img)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Read the image
img = cv2.imread('/content/ele.png')

# Get image dimensions
(h, w) = img.shape[:2]

# Create the shearing matrix
M_shear = np.float32([[1, -0.15, 0], [0, 1, 0]])

# Apply the shear to the image
sheared_img = cv2.warpAffine(img, M_shear, (w, h))

# Display original vs sheared images
cv2_imshow(img)
cv2_imshow(sheared_img)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Read the image
img = cv2.imread('/content/ele.png')

# Split the image into B, G, R channels
b, g, r = cv2.split(img)

# Normalize each channel's values into range [0, 1]
b_norm = b.astype(np.float32) / 255.0
g_norm = g.astype(np.float32) / 255.0
r_norm = r.astype(np.float32) / 255.0

# Merge the normalized channels back into one image
normalized_img = cv2.merge([b_norm, g_norm, r_norm])

# Display the normalized image
cv2_imshow(normalized_img)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Read the image
img = cv2.imread('/content/ele.png')

# Apply Gaussian Blur
blurred_img = cv2.GaussianBlur(img, (3, 3), 0)

# Display original vs blurred images
cv2_imshow(img)
cv2_imshow(blurred_img)
cv2.waitKey(0)
cv2.destroyAllWindows()

